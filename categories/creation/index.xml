<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>creation on cloxnu&#39;s Creative Space</title>
    <link>https://clox.nu/categories/creation/</link>
    <description>Recent content in creation on cloxnu&#39;s Creative Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Jun 2022 17:53:20 +0800</lastBuildDate><atom:link href="https://clox.nu/categories/creation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Palette 1.1 发布</title>
      <link>https://clox.nu/blog/palette-1.1/</link>
      <pubDate>Fri, 10 Jun 2022 17:53:20 +0800</pubDate>
      
      <guid>https://clox.nu/blog/palette-1.1/</guid>
      <description>新版本的 Palette 发布了，这次有了中文标题和描述。
这次还增加了许多可配置的新 Block，其中主要包括一个 Color Mixing 的模块，其 Block 包含自己可以存储调色板的 Palette Block，和一些可供挑选颜色的 Block。
Palette on the App Store</description>
    </item>
    
    <item>
      <title>使用「快捷指令」配合「Taio」完成 Blog 写作并发布</title>
      <link>https://clox.nu/blog/siri-shortcut-and-taio-actions/</link>
      <pubDate>Wed, 01 Jun 2022 14:42:36 +0800</pubDate>
      
      <guid>https://clox.nu/blog/siri-shortcut-and-taio-actions/</guid>
      <description>可能是 Blog 发布流程太长太麻烦，导致我总是不太经常写 Blog，但这次我发现「快捷指令」可以把「Working Copy」的 Commit、Push、Pull 等操作集成起来，而且也可以使用 Taio 动作，于是行动起来。
在 Taio 动作中我写了两个动作，分别是创建 Post 和创建 News，在运行这个快捷指令时可以选择创建 News 还是 Post，如果是 Post，那还需要选择类别，类别列表通过「Taio」的获取目录可以获得现有的类别，否则也可以新建类别。
创建 Post 的动作可以接受一个输入参数，即类别。
这个打开链接就是打开根目录的 README.md 文件，后面的文件指令才能找到正确的路径。
运行 大功告成～ 剩下就是发 Blog 然后等着 GitHub Actions 去处理啦
把这几个 Blog 操作合成一个小组件，简单易用～</description>
    </item>
    
    <item>
      <title>Palette 1.0 上架 App Store</title>
      <link>https://clox.nu/blog/palette-1.0-release/</link>
      <pubDate>Sat, 14 May 2022 14:43:51 +0800</pubDate>
      
      <guid>https://clox.nu/blog/palette-1.0-release/</guid>
      <description>这是一款很随意的 app，但这也是一款可以用 iPad 制作出来并可维护的 app。
链接在这里
楔子 当我第一次吃惊地发现 iPad 居然可以用 Playground 写一个 app 并上架到 App Store 时，于是脑海里瞬间浮现出无数个想法，然后立马去试试。
那时我完全没有接触过 SwiftUI，但是在我尝试试着在 iPad 上写一些代码时，借助 Playground 里的 code snippet，我竟发现 SwiftUI 原来现在已经发展到可以如此便捷高效地构建一个 app。
然后我就决定写一个颜色转换再加上可以配色的超简洁的 app。
说起颜色转换，我不止一次开发跟颜色相关的项目，上次是在钟大的 JSBox 里写了一个颜色转换的 script。
几年前，我曾做过一个叫「今天的颜色」的 app，它的功能非常简单，就是生成一个颜色，每天一个不同的颜色，同时还会把 logo 改成当天的颜色。却也是因为功能太简单，被 App Store 拒绝上架。时到今日，today&amp;rsquo;s color 的 block 在这个 app 会在未来某个版本安排一下～纪念一下。
Just Do It 4 月末，我开始了这个项目，经历了十几个版本的测试，也就大概十几天，上架了 App Store，在前几天还因为 App Store Connect 的服务不稳定稍稍拖慢上架速度。
在 iPad 上开发过程中，还是给了我以下几点不方便的因素：
难以调试，只允许做一个非常简单的项目，一旦复杂起来遇到不好解决的 bug 就得去 mac 上调试 搜索功能不够强大 性能不够，遇到较复杂的语句就无法编译，有时候会导致整个 Playground 卡住（可能是 bug）（就算是 M1 的 iPad 也性能不够，跟 mac 上的 M1 应该是缩水了的） 无法做本地化 等等&amp;hellip; iPad 上开发 app 还有许多需要改善的地方，但这样的思路的确是一个相当好的思路，试想一下如果未来的 iPad 可以允许我们每个人轻松做一个游戏然后上架，每个人都可以把自己的想象发挥到极致而无需担心实现的难度，Apple 官方提供一套无版权的人物角色模型，类似现在的 SF Symbol。下一个时代是人人创作者的时代。</description>
    </item>
    
    <item>
      <title>Telegram Bot 简明教程 II - 收指令与指令键盘</title>
      <link>https://clox.nu/blog/brief-tutorial-on-telegram-bot-ii/</link>
      <pubDate>Wed, 17 Nov 2021 22:30:00 +0800</pubDate>
      
      <guid>https://clox.nu/blog/brief-tutorial-on-telegram-bot-ii/</guid>
      <description>在此之前 Telegram Bot 简明教程 I - 注册与发消息
收指令 python-telegram-bot wiki 页面 介绍了如何使用 Python 脚本实现与 Bot 交互。
以下是根据这个 wiki 页面编写的例程。
接收 /start 指令 from telegram import Update from telegram.ext import Updater, CallbackContext, CommandHandler token = &amp;#39;2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM&amp;#39; def start(update: Update, context: CallbackContext): context.bot.send_message(chat_id=update.effective_chat.id, text=&amp;#34;Let&amp;#39;s start!&amp;#34;) # 或 # update.message.reply_text(&amp;#34;Let&amp;#39;s start!&amp;#34;) if __name__ == &amp;#39;__main__&amp;#39;: updater = Updater(token=token, use_context=True) #1 start_handler = CommandHandler(&amp;#39;start&amp;#39;, start) #2 updater.dispatcher.add_handler(start_handler) #3 updater.start_polling() #4 updater.idle() #5 首先根据 token 创建一个 updater 对象； 定义 start 函数，在函数体中实现给发指令的那个 chat_id 发送消息「Let&amp;rsquo;s start!</description>
    </item>
    
    <item>
      <title>Telegram Bot 简明教程 I - 注册与发消息</title>
      <link>https://clox.nu/blog/brief-tutorial-on-telegram-bot-i/</link>
      <pubDate>Wed, 10 Nov 2021 00:47:13 +0800</pubDate>
      
      <guid>https://clox.nu/blog/brief-tutorial-on-telegram-bot-i/</guid>
      <description>Telegram Bot，简而言之就是运行在 Telegram 上的可交互的「机器人」，你可以给它发送指令让它完成操作或是实现一些功能（付钱、游戏等等），或者可以在 Channel 或 Group 中发送特定消息。
这是 官方介绍。它的主要原理就是开发者通过调用 Telegram Bot API 来实现接收指令、发消息以及实现各种功能。
注册 与 @BotFather 对话，发送指令 /start 开始，/newbot 申请一个新的 Bot 账号。 接着，BotFather 会要求你输入这个 Bot 的名字和 ID。创建完成后，BotFather 会同时给你一个 token，记住这个 token。 此时，已经可以和这个 Bot 互动了，但是想要这个 Bot 也可以主动发消息，这时就要建立一个 Channel，并把这个 Bot 设置为管理员。这个 Channel 如果是 public，其链接可以自定义。这里以 private 为例。 由于 Channel 是 private，我们需要这个 Channel 的 ID 来操作，这里可以通过将 Channel 内的消息转发给 @JsonDumpBot 来查看。可以看到此 Channel 的 ID 是 -1001790411176。 发消息 在官方文档的 Making requests 介绍中讲到，可以使用 GET 或 POST 请求以下 URL。</description>
    </item>
    
    <item>
      <title>使用渐进式 JPEG 图片优化 blog 阅读体验</title>
      <link>https://clox.nu/blog/optimizing-blog-experience-with-progressive-jpeg-pictures/</link>
      <pubDate>Sat, 30 Oct 2021 02:14:30 +0800</pubDate>
      
      <guid>https://clox.nu/blog/optimizing-blog-experience-with-progressive-jpeg-pictures/</guid>
      <description>从写好第一篇多图大图的 blog 那一刻起，我就一直在思考访问者如何快速加载这些图片提高阅读体验，因为这些图片动辄几兆甚至几十兆，而我又不希望压缩这些图片导致质量下降。
所以在以往的多图 blog 中，访问者往往要等待很久的加载时间。
既然是图片大小导致的「硬伤」，加载这些图片几乎都取决于访问者的网速，那么有没有办法从图片本身的角度出发，来优化这种加载时间？
什么是渐进式 JPEG（Progressive JPEG） 我们知道，JPEG 格式是目前兼容性最高，使用范围最广的图片有损压缩格式。而其中的编码方式分为多种，这里主要讨论两种：Baseline JPEG 和 Progressive JPEG。
对于 Baseline JPEG，图片是从上到下一行行顺序存储的，因此在加载图片的时候能看到图片从上到下慢慢显现出来。
而 Progressive JPEG，图片会由模糊到清晰渐进式地分多次存储，因此在加载图片时看到的图片是由模糊到清晰渲染的。
图片来自「简书」
这种渐进式 JPEG 显然可以在图片未加载完全的时候就能看到它的「预览」，而且渐进式 JPEG 的文件大小要略小于 Baseline JPEG。不过渐进式 JPEG 在 Windows 7 以前的 IE 等浏览器不受支持，会在完全加载完成后才显示图片。
目前多图 blog 之所以加载时间很长，是因为这些图片存储的编码方式都是 Baseline JPEG。
🎬 于是，我在之前的 GitHub Actions 配置文件中补充了将这些图片转换为 Progressive JPEG 的命令，当前的 blog 在合并入主干分支后 GitHub Actions 会先使用 hugo 命令创建 HTML1，然后 Progressive JPEG 命令再将所有 JPEG 图片批量处理。
在 Linux 中，使用 ImageMagick 处理图片。其中的 -interlace 选项有提供将图片转换为 Progressive JPEG。</description>
    </item>
    
    <item>
      <title>如何使用相机拍摄包含精准地理位置信息的照片</title>
      <link>https://clox.nu/blog/add-gps-exif-info-to-camera-photos/</link>
      <pubDate>Thu, 07 Oct 2021 17:00:30 +0800</pubDate>
      
      <guid>https://clox.nu/blog/add-gps-exif-info-to-camera-photos/</guid>
      <description>🤔 当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。
可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。因此目前这些相机的解决方案是通过手机蓝牙连接来获取 GPS 信息以写入照片。
在实际使用中，相机需要手机打开对应相机 App 并连接数秒才能更新正确位置，否则相机要么不会写入地理位置，要么写入一个老的地理位置。在拍照时如果总是需要用手机来连接，那一定相当影响拍摄体验。
于是经过一段时间的思考，找到了一个可行的方案：在拍照期间，可以用含有 GPS 模块的设备（例如手机）记录自己的轨迹信息，此后可以根据照片拍摄时间和这些轨迹信息计算拍摄的地点，因而写入照片 EXIF 信息中。
动手 起初，我打算自己实现通过轨迹信息计算拍摄地点的脚本。
首先通过手机上的轨迹记录软件得到一个 GPX 文件，GPX 文件的数据格式本质上是 XML。
&amp;lt;trk&amp;gt; &amp;lt;name&amp;gt;...&amp;lt;/name&amp;gt; ... &amp;lt;trkseg&amp;gt; &amp;lt;trkpt lat=&amp;#34;30.313094&amp;#34; lon=&amp;#34;120.382447&amp;#34;&amp;gt; &amp;lt;ele&amp;gt;8.456302&amp;lt;/ele&amp;gt; &amp;lt;extensions&amp;gt; &amp;lt;speed&amp;gt;0.059180&amp;lt;/speed&amp;gt; &amp;lt;/extensions&amp;gt; &amp;lt;hdop&amp;gt;14.278474&amp;lt;/hdop&amp;gt; &amp;lt;vdop&amp;gt;10.027264&amp;lt;/vdop&amp;gt; &amp;lt;course&amp;gt;-1.000000&amp;lt;/course&amp;gt; &amp;lt;time&amp;gt;2021-05-08T13:31:10Z&amp;lt;/time&amp;gt; &amp;lt;/trkpt&amp;gt; &amp;lt;trkpt lat=&amp;#34;30.313110&amp;#34; lon=&amp;#34;120.382330&amp;#34;&amp;gt; &amp;lt;ele&amp;gt;9.418098&amp;lt;/ele&amp;gt; &amp;lt;extensions&amp;gt; &amp;lt;speed&amp;gt;0.938084&amp;lt;/speed&amp;gt; &amp;lt;/extensions&amp;gt; &amp;lt;hdop&amp;gt;14.331614&amp;lt;/hdop&amp;gt; &amp;lt;vdop&amp;gt;9.951165&amp;lt;/vdop&amp;gt; &amp;lt;course&amp;gt;286.357989&amp;lt;/course&amp;gt; &amp;lt;time&amp;gt;2021-05-08T13:32:06Z&amp;lt;/time&amp;gt; &amp;lt;/trkpt&amp;gt; &amp;lt;/trkseg&amp;gt; &amp;lt;/trk&amp;gt; 类似这样，每个 GPX 文件由 &amp;lt;trk&amp;gt; 标签对组成，&amp;lt;trk&amp;gt; 标签对又由 &amp;lt;trkseg&amp;gt; 标签对组成。事实上在 GPX 记录软件中可以通过暂停、继续在同一个 GPX 文件中记录多个轨迹。因此每个 GPX 文件可以解析出由 TrackSegment 为单位的多组数据。</description>
    </item>
    
    <item>
      <title>如何用命令行将 Linux 服务器上的文件备份至 Dropbox</title>
      <link>https://clox.nu/blog/backup-files-on-linux-to-dropbox/</link>
      <pubDate>Wed, 01 Sep 2021 23:02:22 +0800</pubDate>
      
      <guid>https://clox.nu/blog/backup-files-on-linux-to-dropbox/</guid>
      <description>又进入了新的一月，又到了服务器续费的时候。由于我前些天把我的 travel blog 变成静态页面了，因此原本 serve 了它一段时间的服务器也可以注销掉了，不过服务器上还存有一些需要保留的文件，于是今天想把这些文件放到 Dropbox 中。
参照 官方安装页面，先运行以下命令下载并解压 Dropbox。
$ cd ~ &amp;amp;&amp;amp; wget -O - &amp;#34;https://www.dropbox.com/download?plat=lnx.x86_64&amp;#34; | tar xzf - 然后在 home 目录就会产生一个 .dropbox-dist 目录，同样参照以上官方安装页面，运行这个目录下的 dropboxd 来启动 Dropbox 守护进程。
$ ~/.dropbox-dist/dropboxd 我在运行这句命令之后这段程序执行了一些指令后报错。（我使用的是 Ubuntu 20.04 LTS）
于是立马在 DigitalOcean 中找到答案，我缺少了一些依赖，运行以下命令解决此问题。
$ sudo apt install libc6 libglapi-mesa libxdamage1 libxfixes3 libxcb-glx0 libxcb-dri2-0 libxcb-dri3-0 libxcb-present0 libxcb-sync1 libxshmfence1 libxxf86vm1 安装依赖后，运行上述命令，得到以下输出：
根据提示需要打开 URL 登录自己的账号以绑定这台服务器。打开后界面如下。
如果自己的 Dropbox 账号是通过 Google 或者 Apple 登录的话，需要先登录自己的账号设置一个密码才能在这里登录。
登录之后，控制台会出现一句话，
This computer is now linked to Dropbox.</description>
    </item>
    
    <item>
      <title>使用 GitHub Actions 自动部署我的 travel blog 站点</title>
      <link>https://clox.nu/blog/generate-my-travel-blog-by-github-actions/</link>
      <pubDate>Sat, 14 Aug 2021 20:41:00 +0800</pubDate>
      
      <guid>https://clox.nu/blog/generate-my-travel-blog-by-github-actions/</guid>
      <description>前情提要：在我的 travel blog 的仓库根目录下，有一个叫 gotravel 的文件，运行该文件即可自动生成网站，因此 GitHub Actions 只需要在我每次 push 之后运行这个文件再提交一次就可以了。
在 GitHub 仓库内点击菜单栏的 Actions，然后选择 set up a workflow yourself
然后就会跳转至新建文件页面，以及 GitHub 自动生成最初的 main.yml 文件。
# This is a basic workflow to help you get started with Actions name: CI # Controls when the workflow will run on: # Triggers the workflow on push or pull request events but only for the master branch push: branches: [ master ] pull_request: branches: [ master ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called &amp;#34;build&amp;#34; build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 # Runs a single command using the runners shell - name: Run a one-line script run: echo Hello, world!</description>
    </item>
    
    <item>
      <title>一个奇特的想法 - Site Net</title>
      <link>https://clox.nu/blog/site-net/</link>
      <pubDate>Sat, 20 Feb 2021 11:34:48 +0800</pubDate>
      
      <guid>https://clox.nu/blog/site-net/</guid>
      <description>就在最近两天，我思考到关于如何做一个让知识体系更显而易见的个人网站时，想到了一个可以用一个程序来实现展示各网站关联的点子：类似于一个知识体系的构建，知识点 A 关联到知识点 B，知识点 B 关联到知识点 C，每个站点会指向它内部所含的链接的站点。
程序写出来之后首先就想要测试的就是 Wikipedia 的词条，经过域名过滤和标题过滤（让链接仅指向 Wikipedia 的站点而不是某些参考文献），原站点指向的站点实在是太多，图片上的字都有点看不清了。（以下是 Python 词条搜索 3,000 次的结果）
然后再试了一下 Apple 的中国官网，图比较密集所以将画布放大了一倍
本工程的 GitHub 链接</description>
    </item>
    
    <item>
      <title>使用 Travis CI 自动部署 Hugo 站点</title>
      <link>https://clox.nu/blog/deployment-based-on-travis-ci/</link>
      <pubDate>Tue, 16 Feb 2021 10:58:54 +0800</pubDate>
      
      <guid>https://clox.nu/blog/deployment-based-on-travis-ci/</guid>
      <description>在 GitHub 仓库内创建 .travis.yml 文件并添加以下内容后，即可自动部署此 Hugo 站点。
dist: bionic addons: snaps: - hugo install: - cd ./src/ - git submodule update --init --remote script: - hugo -D after_script: - cd .. - git config --global user.name &amp;#34;Travis CI&amp;#34; - git config --global user.email &amp;lt;your-email&amp;gt; - git remote set-url origin &amp;#34;https://${GITHUB_TOKEN}@github.com/&amp;lt;username&amp;gt;/&amp;lt;repo-name&amp;gt;.git&amp;#34; - git checkout main - git add . - git commit -m &amp;#34;Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER&amp;#34; - git push origin 记得在 travis-ci.</description>
    </item>
    
    <item>
      <title>关于本站</title>
      <link>https://clox.nu/blog/about-this-site/</link>
      <pubDate>Mon, 15 Feb 2021 00:21:45 +0800</pubDate>
      
      <guid>https://clox.nu/blog/about-this-site/</guid>
      <description>本站使用 Hugo 搭建而成，theme 主要使用 PaperMod，将源仓库 adityatelange / hugo-PaperMod fork 到自己的 GitHub 仓库 cloxnu / hugo-PaperMod 并手动增加Mathjax 特性后，本站仓库主题使用 git submodule 拉取。
以下添加 Mathjax 特性过程参考 https://note.qidong.name/2018/03/hugo-mathjax/
手动添加文件 layouts/partials/mathjax.html
在 partials 目录下的文件 extend_head.html 添加代码
即可。
顺便在这里提一下 git submodule 和 git remote 在我 fork 了源仓库之后，使用命令
git remote add upstream https://github.com/adityatelange/hugo-PaperMod.git 来配置一个 remote，参考 Configuring a remote for a fork ，并使用
git fetch upstream 来同步远程仓库，参考 Syncing a fork 。将 Mathjax 特性添加之后，push 到自己 fork 的仓库，随后在本站仓库使用命令
git submodule add https://github.</description>
    </item>
    
    <item>
      <title>学校爬电费状态栏 App 的 macOS 开发日记</title>
      <link>https://clox.nu/blog/energy-charge-in-macos/</link>
      <pubDate>Sat, 23 May 2020 00:35:00 +0800</pubDate>
      
      <guid>https://clox.nu/blog/energy-charge-in-macos/</guid>
      <description>Monitoring the energy charge work on macOS in CJLU.
如何在没接触过 macOS 开发的情况下 4 个小时写一个学校爬电费状态栏 App GitHub链接-Energy_Charge_in_MacOS
About Energy_Charge There is Docker version. 2020-05-23 00:35 更新 连接错误变灰
低电费变红
其他寝室
缘起 学校寝室里配了台台式，写了大半学期的 iOS，这一切都如此顺利。
不过就在刚刚，一位大佬朋友突然向我展示了他找到的查寝室电费网址 POST 参数。这不禁让我陷入了思考（因为平常我得经常看着点电费不然没电费了电脑黑屏警告233）。然后我顺便查了下我们寝室的电费，nm只有 1 块 5 了！！！
开发一个 macOS 的爬电费 App 就这样开始了。
&amp;mdash;- 四个小时前
Hardworking&amp;hellip; Xcode - File - New - Project&amp;hellip;
然后选择 macOS App，这一切看起来如此自然，然而第一个困扰我的出现了 &amp;mdash; url request 如何实现。
一向喜欢用第三方库的我，果不其然又发现了一个好用的 url request 库，它叫 Alamofire。这个库用来写请求超级超级容易，不过我完全不知道请求完成后得到的 request 应该怎么用，后来找到它的文档这里
噢，原来我获得的就是这个网址的 JSON 数据，我只需要使用官方的 JSONSerialization 类就行了，于是我就写成了下面这样，把 JSON 转换 NSDictionary 一层层不断获取，成功得到了电费数值，并将它们写到一个类里去，加了一些代理以便其他类能够得到电费变更通知或错误通知。</description>
    </item>
    
  </channel>
</rss>
