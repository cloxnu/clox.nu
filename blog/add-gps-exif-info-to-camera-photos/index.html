<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>如何使用相机拍摄包含精准地理位置信息的照片 | cloxnu&#39;s Creative Space</title>

<meta name="keywords" content="" />
<meta name="description" content="🤔 当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。
可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。因此目前这些相机的解决方案是通过手机蓝牙连接来获取 GPS 信息以写入照片。
在实际使用中，相机需要手机打开对应相机 App 并连接数秒才能更新正确位置，否则相机要么不会写入地理位置，要么写入一个老的地理位置。在拍照时如果总是需要用手机来连接，那一定相当影响拍摄体验。
于是经过一段时间的思考，找到了一个可行的方案：在拍照期间，可以用含有 GPS 模块的设备（例如手机）记录自己的轨迹信息，此后可以根据照片拍摄时间和这些轨迹信息计算拍摄的地点，因而写入照片 EXIF 信息中。
动手 起初，我打算自己实现通过轨迹信息计算拍摄地点的脚本。
首先通过手机上的轨迹记录软件得到一个 GPX 文件，GPX 文件的数据格式本质上是 XML。
&lt;trk&gt; &lt;name&gt;...&lt;/name&gt; ... &lt;trkseg&gt; &lt;trkpt lat=&#34;30.313094&#34; lon=&#34;120.382447&#34;&gt; &lt;ele&gt;8.456302&lt;/ele&gt; &lt;extensions&gt; &lt;speed&gt;0.059180&lt;/speed&gt; &lt;/extensions&gt; &lt;hdop&gt;14.278474&lt;/hdop&gt; &lt;vdop&gt;10.027264&lt;/vdop&gt; &lt;course&gt;-1.000000&lt;/course&gt; &lt;time&gt;2021-05-08T13:31:10Z&lt;/time&gt; &lt;/trkpt&gt; &lt;trkpt lat=&#34;30.313110&#34; lon=&#34;120.382330&#34;&gt; &lt;ele&gt;9.418098&lt;/ele&gt; &lt;extensions&gt; &lt;speed&gt;0.938084&lt;/speed&gt; &lt;/extensions&gt; &lt;hdop&gt;14.331614&lt;/hdop&gt; &lt;vdop&gt;9.951165&lt;/vdop&gt; &lt;course&gt;286.357989&lt;/course&gt; &lt;time&gt;2021-05-08T13:32:06Z&lt;/time&gt; &lt;/trkpt&gt; &lt;/trkseg&gt; &lt;/trk&gt; 类似这样，每个 GPX 文件由 &lt;trk&gt; 标签对组成，&lt;trk&gt; 标签对又由 &lt;trkseg&gt; 标签对组成。事实上在 GPX 记录软件中可以通过暂停、继续在同一个 GPX 文件中记录多个轨迹。因此每个 GPX 文件可以解析出由 TrackSegment 为单位的多组数据。">
<meta name="author" content="Sidney Liu">
<link rel="canonical" href="https://creative.clox.nu/blog/add-gps-exif-info-to-camera-photos/" />
<link href="/assets/css/stylesheet.min.555a4d6fef760f048c5b1bf30019b077e4b6fb2de917654189208a1f5141f43b.css" integrity="sha256-VVpNb&#43;92DwSMWxvzABmwd&#43;S2&#43;y3pF2VBiSCKH1FB9Ds=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://creative.clox.nu/logo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://creative.clox.nu/logo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://creative.clox.nu/logo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://creative.clox.nu/apple-touch-icon.png">
<link rel="mask-icon" href="https://creative.clox.nu/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.1" />







<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151087524-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<meta property="og:title" content="如何使用相机拍摄包含精准地理位置信息的照片" />
<meta property="og:description" content="🤔 当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。
可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。因此目前这些相机的解决方案是通过手机蓝牙连接来获取 GPS 信息以写入照片。
在实际使用中，相机需要手机打开对应相机 App 并连接数秒才能更新正确位置，否则相机要么不会写入地理位置，要么写入一个老的地理位置。在拍照时如果总是需要用手机来连接，那一定相当影响拍摄体验。
于是经过一段时间的思考，找到了一个可行的方案：在拍照期间，可以用含有 GPS 模块的设备（例如手机）记录自己的轨迹信息，此后可以根据照片拍摄时间和这些轨迹信息计算拍摄的地点，因而写入照片 EXIF 信息中。
动手 起初，我打算自己实现通过轨迹信息计算拍摄地点的脚本。
首先通过手机上的轨迹记录软件得到一个 GPX 文件，GPX 文件的数据格式本质上是 XML。
&lt;trk&gt; &lt;name&gt;...&lt;/name&gt; ... &lt;trkseg&gt; &lt;trkpt lat=&#34;30.313094&#34; lon=&#34;120.382447&#34;&gt; &lt;ele&gt;8.456302&lt;/ele&gt; &lt;extensions&gt; &lt;speed&gt;0.059180&lt;/speed&gt; &lt;/extensions&gt; &lt;hdop&gt;14.278474&lt;/hdop&gt; &lt;vdop&gt;10.027264&lt;/vdop&gt; &lt;course&gt;-1.000000&lt;/course&gt; &lt;time&gt;2021-05-08T13:31:10Z&lt;/time&gt; &lt;/trkpt&gt; &lt;trkpt lat=&#34;30.313110&#34; lon=&#34;120.382330&#34;&gt; &lt;ele&gt;9.418098&lt;/ele&gt; &lt;extensions&gt; &lt;speed&gt;0.938084&lt;/speed&gt; &lt;/extensions&gt; &lt;hdop&gt;14.331614&lt;/hdop&gt; &lt;vdop&gt;9.951165&lt;/vdop&gt; &lt;course&gt;286.357989&lt;/course&gt; &lt;time&gt;2021-05-08T13:32:06Z&lt;/time&gt; &lt;/trkpt&gt; &lt;/trkseg&gt; &lt;/trk&gt; 类似这样，每个 GPX 文件由 &lt;trk&gt; 标签对组成，&lt;trk&gt; 标签对又由 &lt;trkseg&gt; 标签对组成。事实上在 GPX 记录软件中可以通过暂停、继续在同一个 GPX 文件中记录多个轨迹。因此每个 GPX 文件可以解析出由 TrackSegment 为单位的多组数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://creative.clox.nu/blog/add-gps-exif-info-to-camera-photos/" />
<meta property="article:published_time" content="2021-10-07T17:00:30+08:00" />
<meta property="article:modified_time" content="2021-10-07T17:00:30+08:00" /><meta property="og:site_name" content="cloxnu&#39;s creative space" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何使用相机拍摄包含精准地理位置信息的照片"/>
<meta name="twitter:description" content="🤔 当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。
可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。因此目前这些相机的解决方案是通过手机蓝牙连接来获取 GPS 信息以写入照片。
在实际使用中，相机需要手机打开对应相机 App 并连接数秒才能更新正确位置，否则相机要么不会写入地理位置，要么写入一个老的地理位置。在拍照时如果总是需要用手机来连接，那一定相当影响拍摄体验。
于是经过一段时间的思考，找到了一个可行的方案：在拍照期间，可以用含有 GPS 模块的设备（例如手机）记录自己的轨迹信息，此后可以根据照片拍摄时间和这些轨迹信息计算拍摄的地点，因而写入照片 EXIF 信息中。
动手 起初，我打算自己实现通过轨迹信息计算拍摄地点的脚本。
首先通过手机上的轨迹记录软件得到一个 GPX 文件，GPX 文件的数据格式本质上是 XML。
&lt;trk&gt; &lt;name&gt;...&lt;/name&gt; ... &lt;trkseg&gt; &lt;trkpt lat=&#34;30.313094&#34; lon=&#34;120.382447&#34;&gt; &lt;ele&gt;8.456302&lt;/ele&gt; &lt;extensions&gt; &lt;speed&gt;0.059180&lt;/speed&gt; &lt;/extensions&gt; &lt;hdop&gt;14.278474&lt;/hdop&gt; &lt;vdop&gt;10.027264&lt;/vdop&gt; &lt;course&gt;-1.000000&lt;/course&gt; &lt;time&gt;2021-05-08T13:31:10Z&lt;/time&gt; &lt;/trkpt&gt; &lt;trkpt lat=&#34;30.313110&#34; lon=&#34;120.382330&#34;&gt; &lt;ele&gt;9.418098&lt;/ele&gt; &lt;extensions&gt; &lt;speed&gt;0.938084&lt;/speed&gt; &lt;/extensions&gt; &lt;hdop&gt;14.331614&lt;/hdop&gt; &lt;vdop&gt;9.951165&lt;/vdop&gt; &lt;course&gt;286.357989&lt;/course&gt; &lt;time&gt;2021-05-08T13:32:06Z&lt;/time&gt; &lt;/trkpt&gt; &lt;/trkseg&gt; &lt;/trk&gt; 类似这样，每个 GPX 文件由 &lt;trk&gt; 标签对组成，&lt;trk&gt; 标签对又由 &lt;trkseg&gt; 标签对组成。事实上在 GPX 记录软件中可以通过暂停、继续在同一个 GPX 文件中记录多个轨迹。因此每个 GPX 文件可以解析出由 TrackSegment 为单位的多组数据。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://creative.clox.nu/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://creative.clox.nu/posts/creation/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "如何使用相机拍摄包含精准地理位置信息的照片",
      "item": "https://creative.clox.nu/blog/add-gps-exif-info-to-camera-photos/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何使用相机拍摄包含精准地理位置信息的照片",
  "name": "如何使用相机拍摄包含精准地理位置信息的照片",
  "description": "🤔 当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。\n可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。 …",
  "keywords": [
    
  ],
  "articleBody": "🤔 当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。\n可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。因此目前这些相机的解决方案是通过手机蓝牙连接来获取 GPS 信息以写入照片。\n在实际使用中，相机需要手机打开对应相机 App 并连接数秒才能更新正确位置，否则相机要么不会写入地理位置，要么写入一个老的地理位置。在拍照时如果总是需要用手机来连接，那一定相当影响拍摄体验。\n于是经过一段时间的思考，找到了一个可行的方案：在拍照期间，可以用含有 GPS 模块的设备（例如手机）记录自己的轨迹信息，此后可以根据照片拍摄时间和这些轨迹信息计算拍摄的地点，因而写入照片 EXIF 信息中。\n动手 起初，我打算自己实现通过轨迹信息计算拍摄地点的脚本。\n首先通过手机上的轨迹记录软件得到一个 GPX 文件，GPX 文件的数据格式本质上是 XML。\n ... ...   lat=\"30.313094\" lon=\"120.382447\" 8.456302  0.059180  14.278474 10.027264 -1.000000 2021-05-08T13:31:10Z   lat=\"30.313110\" lon=\"120.382330\" 9.418098  0.938084  14.331614 9.951165 286.357989 2021-05-08T13:32:06Z    类似这样，每个 GPX 文件由  标签对组成， 标签对又由  标签对组成。事实上在 GPX 记录软件中可以通过暂停、继续在同一个 GPX 文件中记录多个轨迹。因此每个 GPX 文件可以解析出由 TrackSegment 为单位的多组数据。\n因此，即便有多个 GPX 文件，同样可以解析成以 TrackSegment 为元的多组数据。\nTrackSegment 是由一个个 TrackPoint 组成的，我们假设这些 TrackPoint 都是按时间顺序排列的（事实上除非人为，否则用 GPX 软件记录下来的轨迹都是按照时间顺序排列的，不过跨越时区的记录可能是个大问题），且没有时间重叠，因此我们可以仅用 TrackSegment 的第一个 TrackPoint 的时间（即开始时间）为键，排序所有 TrackSegment，得到 sortedSegments。\n接下来开始遍历照片，取得照片的拍摄时间，然后依据二分法，即可在 O(log n) 的时间内从包含这些 TrackSegment 的起始时间和结束时间的数组中轻松找到这个拍摄时间存在于哪个 TrackSegment，或者不存在于任何一个 TrackSegment。\n不幸的是，相机（可能是部分相机）拍摄的照片的 EXIF 信息里并没有记录时区信息，而 GPX 文件记录了 UTC 时间。\n因此，当遍历到的照片没有找到时区信息时，最好的方法是直接向用户询问这张照片的时区。\n拿到照片的拍摄时间后，若这张照片的拍摄时间不存在于任何一个 TrackSegment，则不会处理这张照片的任何信息；若找到了这张照片在某一 TrackSegment，则继续依据二分法找这张图片的拍摄时间是否刚好是某个 TrackPoint 的时间，或处于两个 TrackPoint 之间的某一时间点。若刚好是某一 TrackPoint 的时间则使用对应轨迹点的经纬度和海拔写入照片即可，若处于两个轨迹点之间，则根据相邻两个轨迹点的时间到拍摄时间的比例计算经纬度和海拔数值。\nexiftool 在以往，我一直以为 exiftool 只是查看和修改一个照片 EXIF 信息的命令行工具，在我正准备在脚本里用这个工具的时候，突然发现这个工具的 Geotagging 功能，居然出人意料地实现了我想要的功能：可以通过包括 GPX 文件在内的多种 GPS 轨迹文件，自动为一个照片或一个目录下所有照片添加位置信息。\n The Geotag tag is used to define the GPS track log data. The geotagging feature is activated by assigning the name of a track log file to this tag. As an example, the following command line adds GPS tags to all images in the “/Users/Phil/Pictures” directory based on GPS positions stored in the track log file “track.log” in the current directory:\nexiftool -geotag=track.log /Users/Phil/Pictures  用以上命令即可使某一路径的所有照片在一 GPS 轨迹文件中查找并修改这些照片的 EXIF 信息。在 Geosync 中同时提到如果 GPS 轨迹或照片未指定时区，则将用当地时区。\n Both the GPS and the image times are assumed to be local unless another timezone is specified (unless taken from GPSTimeStamp which is UTC).   这无疑完美匹配了我想要的功能。\n关于坐标系 GPS 轨迹记录软件记录的经纬度和海拔的标准采用世界大地测量系统（WGS）的最新版本「WGS-84」，而中国大陆法规要求地图提供商使用一种称为 GCJ-02 的坐标系统，它是一种基于 WGS-84 采用一种混淆算法后制定的大地测量系统，因此将测量好的 GPX 轨迹文件导入中国大陆地图提供商的地图中会引起偏差。\n如图是 Google Earth 中深圳地图街道与实际的偏差。\n实际使用 在 iOS 设备中我使用「GPX Tracker」来记录轨迹，这是一款开源的软件，GitHub 上有相应关于坐标系的 issue，其中提到的解决方案是在 App 中可以使用 Open Street Map 即可查看到没有偏差的路径。\n另外，「我的足迹」App 也可记录轨迹，记录的轨迹同样是 WGS-84 标准，不过将轨迹导入到「我的足迹」中也可看到无偏差的轨迹（可能是 App 主动对轨迹进行了坐标系的转换）。\n我最终使用了「GPS Tracker」，因为它支持 Apple Watch 记录，这样不需要耗费手机的电量。\n记录之后，将照片放在同一目录下，使用如下命令\n最终生成了拥有位置的照片，效果相当不错。\n",
  "wordCount" : "265",
  "inLanguage": "en",
  "datePublished": "2021-10-07T17:00:30+08:00",
  "dateModified": "2021-10-07T17:00:30+08:00",
  "author":{
    "@type": "Person",
    "name": "Sidney Liu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://creative.clox.nu/blog/add-gps-exif-info-to-camera-photos/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cloxnu's Creative Space",
    "logo": {
      "@type": "ImageObject",
      "url": "https://creative.clox.nu/logo/favicon.ico"
    }
  }
}
</script>





</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://creative.clox.nu/" accesskey="h" title="I&#39;m cloxnu (Alt + H)">
                <img src="/logo/logo.svg" alt="logo" aria-label="logo"
                    height="35">I&#39;m cloxnu</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://creative.clox.nu/news/" title="📰 𝕹𝖊𝖜𝖘">
                    <span>📰 𝕹𝖊𝖜𝖘</span>
                </a>
            </li>
            <li>
                <a href="https://creative.clox.nu/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://creative.clox.nu/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://clox.nu" title="About">
                    <span>About</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      如何使用相机拍摄包含精准地理位置信息的照片
    </h1>
    <div class="post-meta">

October 7, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Sidney Liu

</div>
  </header> 

  <div class="post-content">
<h2 id="heading">🤔<a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h2>
<p>当我们使用手机拍照时，按下快门的那一刻，程序会自动获取当前地理位置，并将其写入照片中。而当我们拥有海量包含地理位置并通过 iCloud 或者 NAS 管理的照片时，这些照片会被程序自动归类，因此可以省去大量整理照片的时间。</p>
<p>可是当拍照的设备转移到成像质量更好的相机时，我们却很难方便地获取地理位置信息，因为现在大多数的单反/无反相机都不带有 GPS 模块。因此目前这些相机的解决方案是通过手机蓝牙连接来获取 GPS 信息以写入照片。</p>
<p><img src="assets/IMG_0108.jpg" alt="IMG_0108"></p>
<p>在实际使用中，相机需要手机打开对应相机 App 并连接数秒才能更新正确位置，否则相机要么不会写入地理位置，要么写入一个老的地理位置。在拍照时如果总是需要用手机来连接，那一定相当影响拍摄体验。</p>
<p>于是经过一段时间的思考，找到了一个可行的方案：在拍照期间，可以用含有 GPS 模块的设备（例如手机）记录自己的轨迹信息，此后可以根据照片拍摄时间和这些轨迹信息计算拍摄的地点，因而写入照片 EXIF 信息中。</p>
<h2 id="动手">动手<a hidden class="anchor" aria-hidden="true" href="#动手">#</a></h2>
<p>起初，我打算自己实现通过轨迹信息计算拍摄地点的脚本。</p>
<p>首先通过手机上的轨迹记录软件得到一个 GPX 文件，GPX 文件的数据格式本质上是 XML。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;trk&gt;</span>
    <span style="color:#f92672">&lt;name&gt;</span>...<span style="color:#f92672">&lt;/name&gt;</span>
    ...
    <span style="color:#f92672">&lt;trkseg&gt;</span>
        <span style="color:#f92672">&lt;trkpt</span> <span style="color:#a6e22e">lat=</span><span style="color:#e6db74">&#34;30.313094&#34;</span> <span style="color:#a6e22e">lon=</span><span style="color:#e6db74">&#34;120.382447&#34;</span><span style="color:#f92672">&gt;</span>
            <span style="color:#f92672">&lt;ele&gt;</span>8.456302<span style="color:#f92672">&lt;/ele&gt;</span>
            <span style="color:#f92672">&lt;extensions&gt;</span>
                <span style="color:#f92672">&lt;speed&gt;</span>0.059180<span style="color:#f92672">&lt;/speed&gt;</span>
            <span style="color:#f92672">&lt;/extensions&gt;</span>
            <span style="color:#f92672">&lt;hdop&gt;</span>14.278474<span style="color:#f92672">&lt;/hdop&gt;</span>
            <span style="color:#f92672">&lt;vdop&gt;</span>10.027264<span style="color:#f92672">&lt;/vdop&gt;</span>
            <span style="color:#f92672">&lt;course&gt;</span>-1.000000<span style="color:#f92672">&lt;/course&gt;</span>
            <span style="color:#f92672">&lt;time&gt;</span>2021-05-08T13:31:10Z<span style="color:#f92672">&lt;/time&gt;</span>
        <span style="color:#f92672">&lt;/trkpt&gt;</span>
        <span style="color:#f92672">&lt;trkpt</span> <span style="color:#a6e22e">lat=</span><span style="color:#e6db74">&#34;30.313110&#34;</span> <span style="color:#a6e22e">lon=</span><span style="color:#e6db74">&#34;120.382330&#34;</span><span style="color:#f92672">&gt;</span>
            <span style="color:#f92672">&lt;ele&gt;</span>9.418098<span style="color:#f92672">&lt;/ele&gt;</span>
            <span style="color:#f92672">&lt;extensions&gt;</span>
                <span style="color:#f92672">&lt;speed&gt;</span>0.938084<span style="color:#f92672">&lt;/speed&gt;</span>
            <span style="color:#f92672">&lt;/extensions&gt;</span>
            <span style="color:#f92672">&lt;hdop&gt;</span>14.331614<span style="color:#f92672">&lt;/hdop&gt;</span>
            <span style="color:#f92672">&lt;vdop&gt;</span>9.951165<span style="color:#f92672">&lt;/vdop&gt;</span>
            <span style="color:#f92672">&lt;course&gt;</span>286.357989<span style="color:#f92672">&lt;/course&gt;</span>
            <span style="color:#f92672">&lt;time&gt;</span>2021-05-08T13:32:06Z<span style="color:#f92672">&lt;/time&gt;</span>
        <span style="color:#f92672">&lt;/trkpt&gt;</span>
    <span style="color:#f92672">&lt;/trkseg&gt;</span>
<span style="color:#f92672">&lt;/trk&gt;</span>
</code></pre></div><p>类似这样，每个 GPX 文件由 <code>&lt;trk&gt;</code> 标签对组成，<code>&lt;trk&gt;</code> 标签对又由 <code>&lt;trkseg&gt;</code> 标签对组成。事实上在 GPX 记录软件中可以通过暂停、继续在同一个 GPX 文件中记录多个轨迹。因此每个 GPX 文件可以解析出由 <code>TrackSegment</code> 为单位的多组数据。</p>
<p>因此，即便有多个 GPX 文件，同样可以解析成以 <code>TrackSegment</code> 为元的多组数据。</p>
<p><code>TrackSegment</code> 是由一个个 <code>TrackPoint</code> 组成的，我们假设这些 <code>TrackPoint</code> 都是按时间顺序排列的（事实上除非人为，否则用 GPX 软件记录下来的轨迹都是按照时间顺序排列的，不过跨越时区的记录可能是个大问题），且没有时间重叠，因此我们可以仅用 <code>TrackSegment</code> 的第一个 <code>TrackPoint</code> 的时间（即开始时间）为键，排序所有 <code>TrackSegment</code>，得到 <code>sortedSegments</code>。</p>
<p>接下来开始遍历照片，取得照片的拍摄时间，然后依据二分法，即可在 <code>O(log n)</code> 的时间内从包含这些 <code>TrackSegment</code> 的起始时间和结束时间的数组中轻松找到这个拍摄时间存在于哪个 <code>TrackSegment</code>，或者不存在于任何一个 <code>TrackSegment</code>。</p>
<p>不幸的是，相机（可能是部分相机）拍摄的照片的 EXIF 信息里并没有记录时区信息，而 GPX 文件记录了 UTC 时间。</p>
<p>因此，当遍历到的照片没有找到时区信息时，最好的方法是直接向用户询问这张照片的时区。</p>
<p>拿到照片的拍摄时间后，若这张照片的拍摄时间不存在于任何一个 <code>TrackSegment</code>，则不会处理这张照片的任何信息；若找到了这张照片在某一 <code>TrackSegment</code>，则继续依据二分法找这张图片的拍摄时间是否刚好是某个 <code>TrackPoint</code> 的时间，或处于两个 <code>TrackPoint</code> 之间的某一时间点。若刚好是某一 <code>TrackPoint</code> 的时间则使用对应轨迹点的经纬度和海拔写入照片即可，若处于两个轨迹点之间，则根据相邻两个轨迹点的时间到拍摄时间的比例计算经纬度和海拔数值。</p>
<h2 id="exiftool">exiftool<a hidden class="anchor" aria-hidden="true" href="#exiftool">#</a></h2>
<p>在以往，我一直以为 <a href="https://exiftool.org">exiftool</a> 只是查看和修改一个照片 EXIF 信息的命令行工具，在我正准备在脚本里用这个工具的时候，突然发现这个工具的 <a href="https://exiftool.org/geotag.html">Geotagging</a> 功能，居然出人意料地实现了我想要的功能：可以通过包括 GPX 文件在内的多种 GPS 轨迹文件，自动为一个照片或一个目录下所有照片添加位置信息。</p>
<blockquote>
<p>The <code>Geotag</code> tag is used to define the GPS track log data. The geotagging feature is activated by assigning the name of a track log file to this tag. As an example, the following command line adds GPS tags to all images in the &ldquo;/Users/Phil/Pictures&rdquo; directory based on GPS positions stored in the track log file &ldquo;track.log&rdquo; in the current directory:</p>
<pre tabindex="0"><code>exiftool -geotag=track.log /Users/Phil/Pictures
</code></pre></blockquote>
<p>用以上命令即可使某一路径的所有照片在一 GPS 轨迹文件中查找并修改这些照片的 EXIF 信息。在 <code>Geosync</code> 中同时提到如果 GPS 轨迹或照片未指定时区，则将用当地时区。</p>
<blockquote>
<ol start="3">
<li>Both the GPS and the image times are assumed to be local unless another timezone is specified (unless taken from GPSTimeStamp which is UTC).</li>
</ol>
</blockquote>
<p>这无疑完美匹配了我想要的功能。</p>
<h2 id="关于坐标系">关于坐标系<a hidden class="anchor" aria-hidden="true" href="#关于坐标系">#</a></h2>
<p>GPS 轨迹记录软件记录的经纬度和海拔的标准采用世界大地测量系统（WGS）的最新版本「WGS-84」，而中国大陆法规要求地图提供商使用一种称为 GCJ-02 的坐标系统，它是一种基于 WGS-84 采用一种混淆算法后制定的大地测量系统，因此将测量好的 GPX 轨迹文件导入中国大陆地图提供商的地图中会引起偏差。</p>
<p>如图是 Google Earth 中深圳地图街道与实际的偏差。</p>
<p><img src="assets/IMG_111.jpg" alt="深圳地图偏差"></p>
<h2 id="实际使用">实际使用<a hidden class="anchor" aria-hidden="true" href="#实际使用">#</a></h2>
<p>在 iOS 设备中我使用「GPX Tracker」来记录轨迹，这是一款开源的软件，GitHub 上有相应关于坐标系的 <a href="https://github.com/merlos/iOS-Open-GPX-Tracker/issues/192">issue</a>，其中提到的解决方案是在 App 中可以使用 Open Street Map 即可查看到没有偏差的路径。</p>
<p>另外，「我的足迹」App 也可记录轨迹，记录的轨迹同样是 WGS-84 标准，不过将轨迹导入到「我的足迹」中也可看到无偏差的轨迹（可能是 App 主动对轨迹进行了坐标系的转换）。</p>
<p>我最终使用了「GPS Tracker」，因为它支持 Apple Watch 记录，这样不需要耗费手机的电量。</p>
<p><img src="assets/IMG_110.png" alt="图片"></p>
<p>记录之后，将照片放在同一目录下，使用如下命令</p>
<p><img src="assets/image-20211009193300980.png" alt="image-20211009193300980"></p>
<p>最终生成了拥有位置的照片，效果相当不错。</p>
<p><img src="assets/image-20211007200446137.png" alt="image-20211007200446137"></p>

</div>
  <footer class="post-footer">
    <nav class="paginav">
      <a class="prev" href="https://creative.clox.nu/blog/optimizing-blog-experience-with-progressive-jpeg-pictures/">
        <span class="title">« Prev Page</span>
        <br>
        <span>使用渐进式 JPEG 图片优化 blog 阅读体验</span>
      </a>
      <a class="next" href="https://creative.clox.nu/blog/backup-files-on-linux-to-dropbox/">
        <span class="title">Next Page »</span>
        <br>
        <span>如何用命令行将 Linux 服务器上的文件备份至 Dropbox</span>
      </a>
    </nav>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://creative.clox.nu/">cloxnu&#39;s Creative Space</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a><div id="utter-container"></div>
<script src="https://utteranc.es/client.js"
    repo= 'cloxnu/creative.clox.nu'
    issue-term= "pathname"
    theme= 'preferred-color-scheme'
    crossorigin= "anonymous"
    async>
</script>
<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
