<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Telegram Bot 简明教程 II - 收指令与指令键盘 | cloxnu&#39;s Creative Space</title>

<meta name="keywords" content="" />
<meta name="description" content="在此之前 Telegram Bot 简明教程 I - 注册与发消息
收指令 python-telegram-bot wiki 页面 介绍了如何使用 Python 脚本实现与 Bot 交互。
以下是根据这个 wiki 页面编写的例程。
接收 /start 指令 from telegram import Update from telegram.ext import Updater, CallbackContext, CommandHandler token = &#39;2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM&#39; def start(update: Update, context: CallbackContext): context.bot.send_message(chat_id=update.effective_chat.id, text=&#34;Let&#39;s start!&#34;) # 或 # update.message.reply_text(&#34;Let&#39;s start!&#34;) if __name__ == &#39;__main__&#39;: updater = Updater(token=token, use_context=True) #1 start_handler = CommandHandler(&#39;start&#39;, start) #2 updater.dispatcher.add_handler(start_handler) #3 updater.start_polling() #4 updater.idle() #5  首先根据 token 创建一个 updater 对象； 定义 start 函数，在函数体中实现给发指令的那个 chat_id 发送消息「Let&rsquo;s start!">
<meta name="author" content="Sidney Liu">
<link rel="canonical" href="https://clox.nu/blog/brief-tutorial-on-telegram-bot-ii/" />
<link href="/assets/css/stylesheet.min.555a4d6fef760f048c5b1bf30019b077e4b6fb2de917654189208a1f5141f43b.css" integrity="sha256-VVpNb&#43;92DwSMWxvzABmwd&#43;S2&#43;y3pF2VBiSCKH1FB9Ds=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://clox.nu/logo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://clox.nu/logo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://clox.nu/logo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://clox.nu/apple-touch-icon.png">
<link rel="mask-icon" href="https://clox.nu/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.3" />







<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151087524-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<meta property="og:title" content="Telegram Bot 简明教程 II - 收指令与指令键盘" />
<meta property="og:description" content="在此之前 Telegram Bot 简明教程 I - 注册与发消息
收指令 python-telegram-bot wiki 页面 介绍了如何使用 Python 脚本实现与 Bot 交互。
以下是根据这个 wiki 页面编写的例程。
接收 /start 指令 from telegram import Update from telegram.ext import Updater, CallbackContext, CommandHandler token = &#39;2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM&#39; def start(update: Update, context: CallbackContext): context.bot.send_message(chat_id=update.effective_chat.id, text=&#34;Let&#39;s start!&#34;) # 或 # update.message.reply_text(&#34;Let&#39;s start!&#34;) if __name__ == &#39;__main__&#39;: updater = Updater(token=token, use_context=True) #1 start_handler = CommandHandler(&#39;start&#39;, start) #2 updater.dispatcher.add_handler(start_handler) #3 updater.start_polling() #4 updater.idle() #5  首先根据 token 创建一个 updater 对象； 定义 start 函数，在函数体中实现给发指令的那个 chat_id 发送消息「Let&rsquo;s start!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://clox.nu/blog/brief-tutorial-on-telegram-bot-ii/" />
<meta property="article:published_time" content="2021-11-16T22:00:00+08:00" />
<meta property="article:modified_time" content="2021-11-16T22:00:00+08:00" /><meta property="og:site_name" content="cloxnu&#39;s creative space" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Telegram Bot 简明教程 II - 收指令与指令键盘"/>
<meta name="twitter:description" content="在此之前 Telegram Bot 简明教程 I - 注册与发消息
收指令 python-telegram-bot wiki 页面 介绍了如何使用 Python 脚本实现与 Bot 交互。
以下是根据这个 wiki 页面编写的例程。
接收 /start 指令 from telegram import Update from telegram.ext import Updater, CallbackContext, CommandHandler token = &#39;2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM&#39; def start(update: Update, context: CallbackContext): context.bot.send_message(chat_id=update.effective_chat.id, text=&#34;Let&#39;s start!&#34;) # 或 # update.message.reply_text(&#34;Let&#39;s start!&#34;) if __name__ == &#39;__main__&#39;: updater = Updater(token=token, use_context=True) #1 start_handler = CommandHandler(&#39;start&#39;, start) #2 updater.dispatcher.add_handler(start_handler) #3 updater.start_polling() #4 updater.idle() #5  首先根据 token 创建一个 updater 对象； 定义 start 函数，在函数体中实现给发指令的那个 chat_id 发送消息「Let&rsquo;s start!"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://clox.nu/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://clox.nu/posts/creation/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Telegram Bot 简明教程 II - 收指令与指令键盘",
      "item": "https://clox.nu/blog/brief-tutorial-on-telegram-bot-ii/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Telegram Bot 简明教程 II - 收指令与指令键盘",
  "name": "Telegram Bot 简明教程 II - 收指令与指令键盘",
  "description": "在此之前 Telegram Bot 简明教程 I - 注册与发消息\n收指令 python-telegram-bot wiki 页面 介绍了如何使用 Python 脚本实现与 Bot 交互。\n以下是根据这个 wiki 页面编写的例程。\n接收 /start 指令 from telegram import Update from telegram.ext …",
  "keywords": [
    
  ],
  "articleBody": "在此之前 Telegram Bot 简明教程 I - 注册与发消息\n收指令 python-telegram-bot wiki 页面 介绍了如何使用 Python 脚本实现与 Bot 交互。\n以下是根据这个 wiki 页面编写的例程。\n接收 /start 指令 from telegram import Update from telegram.ext import Updater, CallbackContext, CommandHandler token = '2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM' def start(update: Update, context: CallbackContext): context.bot.send_message(chat_id=update.effective_chat.id, text=\"Let's start!\") # 或 # update.message.reply_text(\"Let's start!\") if __name__ == '__main__': updater = Updater(token=token, use_context=True) #1 start_handler = CommandHandler('start', start) #2 updater.dispatcher.add_handler(start_handler) #3 updater.start_polling() #4 updater.idle() #5  首先根据 token 创建一个 updater 对象； 定义 start 函数，在函数体中实现给发指令的那个 chat_id 发送消息「Let’s start!」，并将这个函数与 start 指令关联； 将 start 函数作为 CommandHandler 添加到 update.dispatcher 中； 当前设定的指令开始运作，程序会自动持续地向 Telegram 的服务器发送请求，以实时接收指令； 等待用户 Control-C 或者进程杀死。  运行此程序，并与 Bot 对话，执行指令 /start ，结果如下：\n对话 from telegram import Update from telegram.ext import Updater, CallbackContext, CommandHandler, MessageHandler, Filters token = '2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM' def echo(update: Update, context: CallbackContext): context.bot.send_message(chat_id=update.effective_chat.id, text=update.message.text) if __name__ == '__main__': updater = Updater(token=token, use_context=True) echo_handler = MessageHandler(Filters.text \u0026 (~Filters.command), echo) #1 updater.dispatcher.add_handler(echo_handler) #2 updater.start_polling() updater.idle() 将之前的代码稍作修改：\n 将之前的 start 函数改为 echo 函数，其作用是将发给 Bot 的消息发送回来，并将之前的 CommandHandler 改为 MessageHandler，这里 Filter 的作用是过滤文本和非指令信息； 添加到 dispatcher 中。  运行此程序，并与 Bot 对话，Bot 会将原话发送回来：\n指令键盘 关于这一部分，python-telegram-bot 有一个 例程，和对应的 wiki。\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update from telegram.ext import Updater, CallbackContext, CommandHandler, CallbackQueryHandler def start(update: Update, context: CallbackContext): keyboard = [ [ InlineKeyboardButton(\"Option 1\", callback_data='1'), InlineKeyboardButton(\"Option 2\", callback_data='2'), ], [ InlineKeyboardButton(\"Option 3\", callback_data='3'), ] ] #1 reply_markup = InlineKeyboardMarkup(keyboard) #2 update.message.reply_text(\"Please choose:\", reply_markup=reply_markup) #3 def keyboard_callback(update: Update, context: CallbackContext): #4 query = update.callback_query #5 query.answer() #6 query.edit_message_text(text=f\"Selected option: {query.data}\") #7 if name == '__main__': updater = Updater(token=token, use_context=True) start_handler = CommandHandler('start', start) updater.dispatcher.add_handler(start_handler) updater.dispatcher.add_handler(CallbackQueryHandler(keyboard_callback)) #8 updater.start_polling() updater.idle()  同样回到 start 函数，这次我们更改下 /start 指令内部逻辑，一开始定义了一个二维数组，我们可以简单地理解为定义了两排按钮，第一排是 Option 1 和 Option 2，第二排是 Option 3； 将其转换为 InlineKeyboardMarkup 类型以便发送； 将这个指令键盘作为回复发送； 定义一个新的函数，作为用户按键盘后的 handler； 当用户点击按钮，update.callback_query 中拥有此指令信息，将其定义为 query； 调用 query 的 answer() 方法，即告诉用户「回复」了这条指令，表现为客户端不再显示等待这条指令的 UI； 将用户选择的值作为一条消息覆盖原来的键盘消息； 将此 handler 加入 dispatcher。  运行此程序，并与 Bot 对话，执行指令 /start ，结果如下：\n当点选 “Option 1” 后，出现 Loading 的提示后，原消息更改为以下结果：\n下一步… 未完待续\n",
  "wordCount" : "288",
  "inLanguage": "en",
  "datePublished": "2021-11-16T22:00:00+08:00",
  "dateModified": "2021-11-16T22:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Sidney Liu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://clox.nu/blog/brief-tutorial-on-telegram-bot-ii/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cloxnu's Creative Space",
    "logo": {
      "@type": "ImageObject",
      "url": "https://clox.nu/logo/favicon.ico"
    }
  }
}
</script>





</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://clox.nu/" accesskey="h" title="I&#39;m cloxnu (Alt + H)">
                <img src="/logo/logo.svg" alt="logo" aria-label="logo"
                    height="35">I&#39;m cloxnu</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://clox.nu/news/" title="📰 𝕹𝖊𝖜𝖘">
                    <span>📰 𝕹𝖊𝖜𝖘</span>
                </a>
            </li>
            <li>
                <a href="https://clox.nu/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://clox.nu/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://about.clox.nu" title="About">
                    <span>About</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Telegram Bot 简明教程 II - 收指令与指令键盘
    </h1>
    <div class="post-meta">

November 16, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Sidney Liu

</div>
  </header> 

  <div class="post-content">
<h2 id="在此之前">在此之前<a hidden class="anchor" aria-hidden="true" href="#在此之前">#</a></h2>
<p><a href="../brief-tutorial-on-telegram-bot-i/">Telegram Bot 简明教程 I - 注册与发消息</a></p>
<h2 id="收指令">收指令<a hidden class="anchor" aria-hidden="true" href="#收指令">#</a></h2>
<p><a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions-%E2%80%93-Your-first-Bot">python-telegram-bot wiki 页面</a> 介绍了如何使用 Python 脚本实现与 Bot 交互。</p>
<p>以下是根据这个 wiki 页面编写的例程。</p>
<h3 id="接收-start-指令">接收 <code>/start</code> 指令<a hidden class="anchor" aria-hidden="true" href="#接收-start-指令">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#f92672">from</span> telegram <span style="color:#f92672">import</span> Update
<span style="color:#f92672">from</span> telegram.ext <span style="color:#f92672">import</span> Updater, CallbackContext, CommandHandler

token <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM&#39;</span>


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">start</span>(update: Update, context: CallbackContext):
    context<span style="color:#f92672">.</span>bot<span style="color:#f92672">.</span>send_message(chat_id<span style="color:#f92672">=</span>update<span style="color:#f92672">.</span>effective_chat<span style="color:#f92672">.</span>id, text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Let&#39;s start!&#34;</span>)
    <span style="color:#75715e"># 或</span>
    <span style="color:#75715e"># update.message.reply_text(&#34;Let&#39;s start!&#34;)</span>


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    updater <span style="color:#f92672">=</span> Updater(token<span style="color:#f92672">=</span>token, use_context<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>) <span style="color:#75715e">#1</span>
    start_handler <span style="color:#f92672">=</span> CommandHandler(<span style="color:#e6db74">&#39;start&#39;</span>, start) <span style="color:#75715e">#2</span>
    updater<span style="color:#f92672">.</span>dispatcher<span style="color:#f92672">.</span>add_handler(start_handler) <span style="color:#75715e">#3</span>
    updater<span style="color:#f92672">.</span>start_polling() <span style="color:#75715e">#4</span>
    updater<span style="color:#f92672">.</span>idle() <span style="color:#75715e">#5</span>
</code></pre></div><ol>
<li>首先根据 token 创建一个 <code>updater</code> 对象；</li>
<li>定义 <code>start</code> 函数，在函数体中实现给发指令的那个 <code>chat_id</code> 发送消息「Let&rsquo;s start!」，并将这个函数与 <code>start</code> 指令关联；</li>
<li>将 <code>start</code> 函数作为 <code>CommandHandler</code> 添加到 <code>update.dispatcher</code> 中；</li>
<li>当前设定的指令开始运作，程序会自动持续地向 Telegram 的服务器发送请求，以实时接收指令；</li>
<li>等待用户 Control-C 或者进程杀死。</li>
</ol>
<p>运行此程序，并与 Bot 对话，执行指令 <code>/start</code> ，结果如下：</p>
<p><img src="assets/IMG_1.jpg" alt="图片"></p>
<h3 id="对话">对话<a hidden class="anchor" aria-hidden="true" href="#对话">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#f92672">from</span> telegram <span style="color:#f92672">import</span> Update
<span style="color:#f92672">from</span> telegram.ext <span style="color:#f92672">import</span> Updater, CallbackContext, CommandHandler, MessageHandler, Filters

token <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2110628450:AAHQ78uj42ddtdsx0gKfaZGyFUhpnQ13vyM&#39;</span>


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">echo</span>(update: Update, context: CallbackContext):
    context<span style="color:#f92672">.</span>bot<span style="color:#f92672">.</span>send_message(chat_id<span style="color:#f92672">=</span>update<span style="color:#f92672">.</span>effective_chat<span style="color:#f92672">.</span>id, text<span style="color:#f92672">=</span>update<span style="color:#f92672">.</span>message<span style="color:#f92672">.</span>text)
    

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    updater <span style="color:#f92672">=</span> Updater(token<span style="color:#f92672">=</span>token, use_context<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
    echo_handler <span style="color:#f92672">=</span> MessageHandler(Filters<span style="color:#f92672">.</span>text <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">~</span>Filters<span style="color:#f92672">.</span>command), echo) <span style="color:#75715e">#1</span>
    updater<span style="color:#f92672">.</span>dispatcher<span style="color:#f92672">.</span>add_handler(echo_handler) <span style="color:#75715e">#2</span>
    updater<span style="color:#f92672">.</span>start_polling()
    updater<span style="color:#f92672">.</span>idle()
</code></pre></div><p>将之前的代码稍作修改：</p>
<ol>
<li>将之前的 <code>start</code> 函数改为 <code>echo</code> 函数，其作用是将发给 Bot 的消息发送回来，并将之前的 <code>CommandHandler</code> 改为 <code>MessageHandler</code>，这里 <code>Filter</code> 的作用是过滤文本和非指令信息；</li>
<li>添加到 <code>dispatcher</code> 中。</li>
</ol>
<p>运行此程序，并与 Bot 对话，Bot 会将原话发送回来：</p>
<p><img src="assets/IMG_2.jpg" alt="图片"></p>
<h3 id="指令键盘">指令键盘<a hidden class="anchor" aria-hidden="true" href="#指令键盘">#</a></h3>
<p>关于这一部分，python-telegram-bot 有一个 <a href="https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/inlinekeyboard.py">例程</a>，和对应的 <a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/InlineKeyboard-Example">wiki</a>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#f92672">from</span> telegram <span style="color:#f92672">import</span> InlineKeyboardButton, InlineKeyboardMarkup, Update
<span style="color:#f92672">from</span> telegram.ext <span style="color:#f92672">import</span> Updater, CallbackContext, CommandHandler, CallbackQueryHandler

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">start</span>(update: Update, context: CallbackContext):
    keyboard <span style="color:#f92672">=</span> [
        [
            InlineKeyboardButton(<span style="color:#e6db74">&#34;Option 1&#34;</span>, callback_data<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;1&#39;</span>),
            InlineKeyboardButton(<span style="color:#e6db74">&#34;Option 2&#34;</span>, callback_data<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2&#39;</span>),
        ],
        [
            InlineKeyboardButton(<span style="color:#e6db74">&#34;Option 3&#34;</span>, callback_data<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;3&#39;</span>),
        ]
    ] <span style="color:#75715e">#1</span>
    reply_markup <span style="color:#f92672">=</span> InlineKeyboardMarkup(keyboard) <span style="color:#75715e">#2</span>
    update<span style="color:#f92672">.</span>message<span style="color:#f92672">.</span>reply_text(<span style="color:#e6db74">&#34;Please choose:&#34;</span>, reply_markup<span style="color:#f92672">=</span>reply_markup) <span style="color:#75715e">#3</span>


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">keyboard_callback</span>(update: Update, context: CallbackContext): <span style="color:#75715e">#4</span>
    query <span style="color:#f92672">=</span> update<span style="color:#f92672">.</span>callback_query <span style="color:#75715e">#5</span>
    query<span style="color:#f92672">.</span>answer() <span style="color:#75715e">#6</span>
    query<span style="color:#f92672">.</span>edit_message_text(text<span style="color:#f92672">=</span><span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Selected option: </span><span style="color:#e6db74">{</span>query<span style="color:#f92672">.</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>) <span style="color:#75715e">#7</span>
    
<span style="color:#66d9ef">if</span> name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    updater <span style="color:#f92672">=</span> Updater(token<span style="color:#f92672">=</span>token, use_context<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
    start_handler <span style="color:#f92672">=</span> CommandHandler(<span style="color:#e6db74">&#39;start&#39;</span>, start)
    updater<span style="color:#f92672">.</span>dispatcher<span style="color:#f92672">.</span>add_handler(start_handler)
    updater<span style="color:#f92672">.</span>dispatcher<span style="color:#f92672">.</span>add_handler(CallbackQueryHandler(keyboard_callback)) <span style="color:#75715e">#8</span>
    updater<span style="color:#f92672">.</span>start_polling()
    updater<span style="color:#f92672">.</span>idle()
</code></pre></div><ol>
<li>同样回到 <code>start</code> 函数，这次我们更改下 <code>/start</code> 指令内部逻辑，一开始定义了一个二维数组，我们可以简单地理解为定义了两排按钮，第一排是 <code>Option 1</code> 和 <code>Option 2</code>，第二排是 <code>Option 3</code>；</li>
<li>将其转换为 <code>InlineKeyboardMarkup</code> 类型以便发送；</li>
<li>将这个指令键盘作为回复发送；</li>
<li>定义一个新的函数，作为用户按键盘后的 handler；</li>
<li>当用户点击按钮，<code>update.callback_query</code> 中拥有此指令信息，将其定义为 <code>query</code>；</li>
<li>调用 <code>query</code> 的 <code>answer()</code> 方法，即告诉用户「回复」了这条指令，表现为客户端不再显示等待这条指令的 UI；</li>
<li>将用户选择的值作为一条消息覆盖原来的键盘消息；</li>
<li>将此 handler 加入 <code>dispatcher</code>。</li>
</ol>
<p>运行此程序，并与 Bot 对话，执行指令 <code>/start</code> ，结果如下：</p>
<p><img src="assets/IMG_3.jpg" alt="图片"></p>
<p>当点选 &ldquo;Option 1&rdquo; 后，出现 Loading 的提示后，原消息更改为以下结果：</p>
<p><img src="assets/IMG_4.jpg" alt="图片"></p>
<h2 id="下一步">下一步&hellip;<a hidden class="anchor" aria-hidden="true" href="#下一步">#</a></h2>
<p>未完待续</p>

</div>
  <footer class="post-footer">
    <nav class="paginav">
      <a class="next" href="https://clox.nu/blog/brief-tutorial-on-telegram-bot-i/">
        <span class="title">Next Page »</span>
        <br>
        <span>Telegram Bot 简明教程 I - 注册与发消息</span>
      </a>
    </nav>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://clox.nu/">cloxnu&#39;s Creative Space</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a><div id="utter-container"></div>
<script src="https://utteranc.es/client.js"
    repo= 'cloxnu/clox.nu'
    issue-term= "pathname"
    theme= 'preferred-color-scheme'
    crossorigin= "anonymous"
    async>
</script>
<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
